// E: DOM Element Factory
//
// Overview
//
//    E(<ElemProps>, ...<Content>) -> <DOMElement>
//    E.set(<ElemProps>)         -> <E>
//
// API changes KFAT --> TF:
//    E.derive(name?, props)  -->  E.set(props)
//    E.new(tag?, attrs)      -->  E(props, ...content)
//    <props>.{$tag, $ns, $attrs, $events, $name}
//    Removed: <attrs>.{content, listeners, style}
//    ?...  -->  &...
//    Added: per-element pattern selectors ("&.foo")
//    <E> does not stringize
//    <props>.$attrs.class = names to be *added* to `class` (after selector)
//    No reactivity.
//    Content is flattened (to arbitrary levels).
//    Removed: eventStream, dragStream
//
// API changes TF --> IRK:
//    Removed: E([...content])
//    Reactivity.
//
//
// Content is one of the following:
//
//     - null, undefined, or "" (these are ignored)
//     - DOM Node
//     - string
//     - Array of Content
//     - Thunk of Content
//
// ElemProps
//
//   ElemProps objects describe element/class behavior.  Each entry can
//   describe one of the following:
//
//    - A CSS declaration: key/value = CSS property name/value
//    - A non-CSS definition: key âˆˆ {"$tag", "$ns", "$name", "$attrs"}
//    - A sub-rule: key = selector pattern; value = ElemProps
//
//   Non-CSS property keys begin with `$`.  Sub-rules keys contain a `&`.
//   Other keys are treated as CSS propery names, either using JS
//   (camel-case) or CSS syntax.
//
//   The value of a sub-rule entry is an ElemProps value that may not contain
//   non-CSS properties.
//
//   Non-CSS properties:
//
//     `$tag` -> a DOM element type (tag) name
//
//     `$ns` -> an XML namespace, or `null` for the default (HTML).
//
//     `$name` -> a string to be used as a basis for a class name when a
//         modified (derived) factory is created.
//
//     `$attrs` -> objects whose entries map DOM element attribute names to
//         strings.  These entries are merged with inherited entries,
//         overriding on a per-attribute basis.
//
//         The `class` attribute of each element is managed by the element
//         factory, but `$attrs` may contain a value for `class`.  If
//         present, the classes it names will be applied to elements in
//         addition to the classes auto-generated by the factory.
//
// Reactivity
//
//    We isolate evaluation of content, attribute values, and CSS property
//    values.  This means that these values may be supplied as thunks, and
//    when their underlying values change, the changes will not invalidate
//    the calling cell -- the returned element or factory will persist and
//    changes will be applied to it internally.
//
//    Any change to one or more content values will result in re-parenting
//    of all child nodes.
//
// Design Notes
//
//    For efficiency, we dynamically create CSS classes so that each
//    property does not need to be individually assigned to the style object
//    of every DOM element.  This is why the API exposes the notion of
//    factory objects that can be "modified" (derived from others): it
//    allows the user to control whether a CSS stylesheet rule should be
//    created.  Creating a new factory stores all the new properties in a
//    stylesheet rule, while passing properties when constructing an element
//    applies them directly to the element's style object (which may involve
//    more per-element creation overhead, but can avoid the overhead of
//    dynamically creating a class).
//
//    For convenience, other aspects of element creation -- tag name,
//    namespace, attributes, and event handlers -- are also supported by
//    element factories, so that a single factory object can represent all
//    inputs required to create a single DOM element (except for element
//    content, which generally cannot be inherited because elements can
//    exist in only one placed in the DOM tree).
//
// Usage Notes
//
//    In general, user-defined controls built on this library will define
//    one or more factory objects (dependening on how many types of elements
//    are involved in the control) and a "constructor" function that creates
//    and populates elements.  The question then arises of how users may
//    customize the different factories involved in creating constituent
//    elements.  Some options:
//
//     a) The constructor abstracts all the degrees of freedom.
//
//     b) The constructor accepts one or more `prop` objects that will be
//        directly fed to a factory when creating an element.
//
//     c) The constructor accepts factories as parameters (and the library
//        exposes a corresponding set of default factories).  This gives
//        consumers flexibility in deriving new factories, so that not all
//        declarations need to be applied per-element, but it complicates
//        the simplest use case.
//
//     d) The library exposes a facory object with the ability to derive new
//        factory objects as well as create control instances.  This
//        provides the benefits of (b) and (c) while keeping usage simple.
//        However, it complicates the implementation.

import {isolate, demand, isThunk, onDrop} from "./i.js";
import test from "./test.js";

const D = document;
const newElement = (tagName, ns) =>
      ns ? D.createElementNS(ns, tagName) : D.createElement(tagName);

//------------------------------------------------------------------------
// Normalize CSS property names
//------------------------------------------------------------------------

let throwError = (arg) => {
    throw Error(arg);
};

// Memoize a function that accepts a single string argument
//
let memoize = (fn) => {
    const cache = new Map();
    return (arg) => {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    }
};

// Create style object for detecting browser-specific prefixing
//
const styleObject = newElement("div").style;

const prefixes = [null, "webkit", "Moz", "ms", "css"];

// Convert a generic JavaScript style property name (camel case) to the
// browser-specific variant (camel case) for the curret browser.
//
// E.g.  "boxSizing" -> "MozBoxSizing"   [on some browers]
//
const normalizeName = (name) => {
    for (const prefix of prefixes) {
        const prop = (prefix
                      ? prefix + name[0].toUpperCase() + name.substr(1)
                      : name);
        // Yes, the "in" operator includes properties like "toString", but
        // presumably actual property will have to avoid these conflicts.
        if (prop in styleObject) {
            return prop;
        }
    }
    return name;
};

// Convert a generic JavaScript style property name (camel case) to a CSS
// property name recognized by the current browser.  The resulting form is
// what needs to appear within CSS property values (like `transition`).
//
// E.g.  "boxSizing" -> "-moz-box-sizing"   [on some browser]
//
let cssName = (name) => {
    return normalizeName(name)
        .replace(/([A-Z])/g, "-$1").toLowerCase()
        .replace(/^(webkit|ms)/, "-$1");
};

cssName = memoize(cssName);

// Convert JavaScript values to strings suitable for CSS.  Converts numbers
// to dimensionts in "px" units.  Within strings, replace "#{NAME}" with
// cssName("NAME").
//
const cssValue = (value) => {
    if (typeof value == "string") {
        return value.replace(/#\{(.*?)\}/g, (_, name) => cssName(name));
    } else if (typeof value == "number") {
        return value + "px";
    } else {
        return "";
    }
};

if (test) {
    let {eq} = test;

    eq("float", cssName("float"));
    eq("-webkit-box-flex", cssName("boxFlex"));

    eq("2px", cssValue(2));
    eq("float -webkit-transform -moz-bar -ms-baz",
       cssValue("#{float} #{transform} #{MozBar} #{msBaz}"));
}

//------------------------------------------------------------------------
// Construct non-conflicting class names
//------------------------------------------------------------------------

const allNames = new Set();
let nextNum = 1;

// Return a name different from all previous results
//
const getUniqueName = (name) => {
    while (allNames.has(name)) {
        // append or replace trailing number with a new one
        const m = name.match(/(.*?)(\d*)$/);
        name = m[1] + nextNum++;
    }
    allNames.add(name);
    onDrop(_ => allNames.delete(name));
    return name;
};

//------------------------------------------------------------------------
// Dynamic style sheet manipulation
//------------------------------------------------------------------------

// Add a new stylesheet to hold our generated CSS rules
D.head.appendChild(newElement("style"));
const styleSheet = D.styleSheets[D.styleSheets.length - 1];

// Dynamically create an empty style sheet rule, and return the style
// object.
//
const insertRule = (selector) => {
    styleSheet.insertRule(selector + " {}", 0);
    return styleSheet.cssRules[0];
};

// Remove rules matching selectors.
//
const deleteRules = (selectorSet) => {
    let rule;
    for (let i = 0; (rule = styleSheet.cssRules[i]) != null; ++i) {
        if (selectorSet.has(rule.selectorText)) {
            styleSheet.deleteRule(i);
            --i;
        }
    }
};

// Assign an individual property to a style object.
//
const setStyleProperty = (style, name, value) => {
    if (isThunk(value)) {
        isolate(_ => setStyleProperty(style, name, demand(value)));
    } else {
        name = cssName(name);
        style[name] = (value == null ? "" : cssValue(value));
    }
};

// Apply declarations in `decls` to style object `style`
//
const setStyleProperties = (style, decls) => {
    if (decls) {
        for (let key in decls) {
            setStyleProperty(style, key, decls[key])
        }
    }
};

// Replace "&" wildcard in pattern with `context`
//
const expandSelector = (pattern, context) =>
      pattern ? pattern.replace(/\&/g, context) : context;

// Create and add a stylesheet rule for each member of rules[].
//
let defineRules = (rules, context) => {
    const added = new Set();
    for (const {selector, decls} of rules || []) {
        let ruleSelector = expandSelector(selector, context);
        added.add(ruleSelector);
        const style = insertRule(ruleSelector).style;
        setStyleProperties(style, decls);
    }
    return added;
};

//------------------------------------------------------------------------
// DOM Node manipulation & ElemFactory
//------------------------------------------------------------------------

let setListener = (elem, name, fn) => {
    elem.addEventListener(name, fn);
};

let setListeners = (e, o) => {
    for (let name in o) {
        setListener(e, name, o[name]);
    }
};

// Set attribute `name` to `value`.  Do not assume values have not already
// been set on the element; this can be re-evaluted in an isolated function.
//
let setAttr = (e, name, value) => {
    if (isThunk(value)) {
        isolate(_ => setAttr(e, name, demand(value)));
    } else if (typeof value == "function") {
        throw Error("bad attribute");
    } else {
        // HTML attributes are case-insensitive, but SVG is case-sensitive,
        // so we cannot convert camelCase to dashed-words.  Ironically, SVG
        // also uses dash-delimited attribute names, and is the main case in
        // which we would have liked to use camelCase as shorthand.
        e.setAttribute(name, String(value));
    }
};

let setAttrs = (e, attrs, autoClass) => {
    for (let key in attrs) {
        if (key == "class") {
            isolate(_ => {
                let value = demand(attrs[key]);
                e.setAttribute(key, autoClass + (value ? " " + value : ""));
            });
        } else {
            setAttr(e, key, attrs[key]);
        }
    }
    if (autoClass && !("class" in attrs)) {
        e.setAttribute("class", autoClass);
    }
};

let badNodes = [];

let badNodeText = (value) => {
    // window.BADNODES = badNodes;   // expose for debugging
    badNodes.push(value);
    return D.createTextNode("<BADNODE[" + (badNodes.length - 1) + "]>");
};

let prepareNode = (node) =>
    (node instanceof Node
     ? node
     : D.createTextNode(typeof node == "string" ? node : badNodeText(node)));

// Replace content of element `e` with `content` (a string, DOM element, or
// array of strings/elements).
//
let setContent = (e, content) => {
    // Remove existing content
    while (e.firstChild) {
        e.removeChild(e.firstChild);
    }

    let appendContent = child => {
        // Allow "holes" in the content array
        child = demand(child);
        if (child instanceof Array) {
            child.forEach(appendContent);
        } else if (child != null && child !== "") {
            e.appendChild(prepareNode(child));
        }
    };

    appendContent(content);
};

//----------------------------------------------------------------
// E: Element Factory
//----------------------------------------------------------------

// ElemState objects are internal values that store information needed by
// an Element Factory.
//
//   tag      = DOM element tag name
//   ns       = null, or XML namespace
//   events   = object: event name -> function
//   name     = base for class name generation
//   attrs    = object: attributeName -> string
//   selector = a selector used to identify elements created from the EF
//              instance, such as ".C0.C1".  The selector includes class
//              names of each parent EF in order to increase the specificity
//              of the resulting rule.
//

let defaultES = {
    tag: "div",
    ns: null,
    attrs: {},
    selector: "",
    name: "E0",
};

// Extract components of a `props` value.
//
//   esIn: ElemState
//   props: ElemProps
//
let splitProps = (esIn, propsIn) => {
    if (propsIn == null) {
        return [esIn, []];
    }
    if (typeof propsIn != "object") {
        throw new Error("Bad `props` value");
    }

    let es = {...esIn};
    let rules = [];

    let split = (props, selector) => {
        let decls;

        for (let key in props) {
            let value = props[key];
            if (key[0] == "$") {
                // non-CSS property
                if (selector) {
                    throw new Error("Non-CSS option inside pattern rule: "
                                    + selector + " {" + key + ": ...}")
                } else if (key == "$tag") {
                    es.tag = value;
                } else if (key == "$ns") {
                    es.ns = value;
                } else if (key == "$events") {
                    es.events = value;
                } else if (key == "$name") {
                    es.name = value;
                } else if (key == "$attrs") {
                    es.attrs = {...es.attrs, ...value};
                } else {
                    throw new Error("Bad prop: " + key);
                }
            } else if (/\?/.test(key)) {
                throw new Error("Bad prop: " + key);
            } else if (/\&/.test(key)) {
                // selector pattern
                split(value, expandSelector(key, selector || "&"));
            } else {
                decls = decls || {};
                decls[key] = value;
            }
        }
        if (decls) {
            rules.push({selector, decls});
        }
    };
    split(propsIn, null);

    return [es, rules];
};

if (test) {
    let [es, rules] = splitProps(defaultES, {x: 1, "&.c":{y:2}});
    test.eq(rules.length, 2);
    test.eq(rules[0].selector, "&.c");
    test.eq(rules[1].selector, null);
}

// Create a derived ElemState value
//
let createES = (esIn, props) => {
    let [es, rules] = splitProps(esIn, props);

    if (rules.length > 0) {
        let className = getUniqueName(es.name);
        es.selector = es.selector + "." + className;
        let added = defineRules(rules, es.selector);
        // release allocated resources
        onDrop(_ => {
            deleteRules(added);
        });
    }
    return es;
};

// Assign element attributes
//
let setElem = (e, es, rules) => {
    let {attrs, selector, events} = es;

    if (rules[0]) {
        if (rules[0].selector) {
            // Selector patterns require a stylesheet rule, which requires a
            // unique ID.  In this case, we entirely avoid using `e.style`
            // so that "&:hover:{...}" styles (selector = "#I0:hover") will
            // override element styles (selector = "#I0").
            if (!attrs.id) {
                attrs = {...attrs, id: getUniqueName("I0")};
            }
            defineRules(rules, "#" + attrs.id);
        } else {
            // Assert: rules.length == 1
            // In the simple case we do not need a stylesheet rule.
            setStyleProperties(e.style, rules[0].decls);
        }
    }

    setAttrs(e, attrs, selector.replace(/\./g, " ").substr(1));
    setListeners(e, events || []);
    return e;
};

// Note: $ns and $tag have no effect, since `e` has already been created.
//
let setProps = (e, props) => {
    let [es, rules] = splitProps(defaultES, props);
    setElem(e, es, rules);
};

// Create a DOM element
//
let createElem = (esIn, props, content) => {
    let [es, rules] = splitProps(esIn, props);
    let e = newElement(es.tag, es.ns);
    setElem(e, es, rules);
    isolate(_ => setContent(e, content));
    return e;
};

// Construct a new factory function/object.
//
let newFactory = (es) => {
    let f = (props, ...content) => createElem(es, props, content);
    f.set = (props) => newFactory(createES(es, props));
    return f;
};

let E = newFactory(defaultES);

export {
    E as default,
    E,
    setContent,
    setProps,
};

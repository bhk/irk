// E: DOM Element Factory
//
// Overview
//
//    E.set(<ElemProps>)         -> <E>
//    E(<ElemProps>, ...content) -> <DOMElement>
//    E([...content])      -> <DOMElement>
//
// Changes for game.js:
//
//  - Treat attrs.class, if it exists, as *extra* classes to be added to
//    selector.
//  - Remove `cssFloat` -> `float` translation
//  - flatten content arrays (not just one level down)
//  - E.derive() -> E.set()
//  - E.new()    -> E()
//  - E() accepts props, just like E.set()
//  - PROPS.{$tag, $ns, $attrs, $events} can be passed to E() *and* E.set()
//  - remove ATTRS.{content, listeners, style}
//  - `?` --> `&`
//  - sub-rules (pattern selectors) can be used on individual elements
//  - attrs.style not supported
//
// ElemProps
//
//   ElemProps objects are user-provided values.  Each entry describes:
//
//   - A CSS declaration: key = property name
//   - A sub-rule: key = selector pattern
//   - A non-CSS property: key is one of {"$tag", "$ns", "$attrs", "$name"}
//
//   Non-CSS property keys begin with `$`.  Sub-rules keys contain a `&`.
//   Other keys are treated as CSS propery names, either using JS
//   (camel-case) or CSS syntax.
//
//   The value of a sub-rule entry is a `props` value that may not contain
//   non-CSS properties.
//
//   Non-CSS properties:
//
//     `$attrs` -> objects whose entries map DOM element attribute names to
//         strings.  These entries are merged with inherited entries,
//         overriding on a per-attribute basis.
//
//         The `class` attribute of each element is managed by the element
//         factory, but `$attrs` may contain a value for `class`.  If
//         present, the classes it names will be applied to elements in
//         addition to the classes auto-generated by the factory.
//
//     `$ns` -> an XML namespace, or `null` for the default (HTML).
//
//     `$tag` -> a DOM element type (tag) name
//
//     `$name` -> a string to be used as a basis for a class name when a
//         modified (derived) factory is created.
//
// Design Notes
//
//    For efficiency, we dynamically create CSS classes so that each
//    property does not need to be individually assigned to the style object
//    of every DOM element.  This is why the API exposes the notion of
//    factory objects that can be "modified" (derived from others): it
//    allows the user to control whether a CSS stylesheet rule should be
//    created.  Creating a new factory stores all the new properties in a
//    stylesheet rule, while passing properties when constructing an element
//    applies them directly to the element's style object (which may involve
//    more per-element creation overhead, but can avoid the overhead of
//    dynamically creating a class).
//
//    For convenience, other aspects of element creation -- tag name,
//    namespace, attributes, and event handlers -- are also supported by
//    element factories, so that a single factory object can represent all
//    inputs required to create a single DOM element (except for element
//    content, which generally cannot be inherited because elements can
//    exist in only one placed in the DOM tree).
//
// Usage Notes
//
//    In general, user-defined controls built on this library will define
//    one or more factory objects (dependening on how many types of elements
//    are involved in the control) and a "constructor" function that creates
//    and populates elements.  The question then arises of how users may
//    customize the different factories involved in creating constituent
//    elements.  Some options:
//
//     a) The constructor abstracts all the degrees of freedom.
//
//     b) The constructor accepts one or more `prop` objects that will be
//        directly fed to a factory when creating an element.
//
//     c) The constructor accepts factories as parameters (and the library
//        exposes a corresponding set of default factories).  This gives
//        consumers flexibility in deriving new factories, so that not all
//        declarations need to be applied per-element, but it complicates
//        the simplest use case.
//
//     d) The library exposes a facory object with the ability to derive new
//        factory objects as well as create control instances.  This
//        provides the benefits of (b) and (c) while keeping usage simple.
//        However, it complicates the implementation.

const D = document;
const newElement = (tagName, ns) =>
      ns ? D.createElementNS(ns, tagName) : D.createElement(tagName);

//------------------------------------------------------------------------
// Normalize CSS property names
//------------------------------------------------------------------------

let throwError = (arg) => {
    throw Error(arg);
};

// Memoize a function that accepts a single string argument
//
let memoize = (fn) => {
    const cache = new Map();
    return (arg) => {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    }
};

// Create style object for detecting browser-specific prefixing
//
const styleObject = newElement("div").style;

const prefixes = [null, "webkit", "Moz", "ms", "css"];

// Convert a generic JavaScript style property name (camel case) to the
// browser-specific variant (camel case) for the curret browser.
//
// E.g.  "boxSizing" -> "MozBoxSizing"   [on some browers]
//
const normalizeName = (name) => {
    for (const prefix of prefixes) {
        const prop = (prefix
                      ? prefix + name[0].toUpperCase() + name.substr(1)
                      : name);
        // Yes, the "in" operator includes properties like "toString", but
        // presumably actual property will have to avoid these conflicts.
        if (prop in styleObject) {
            return prop;
        }
    }
    return name;
};

// Convert a generic JavaScript style property name (camel case) to a CSS
// property name recognized by the current browser.  The resulting form is
// what needs to appear within CSS property values (like `transition`).
//
// E.g.  "boxSizing" -> "-moz-box-sizing"   [on some browser]
//
let cssName = (name) => {
    return normalizeName(name)
        .replace(/([A-Z])/g, "-$1").toLowerCase()
        .replace(/^(webkit|ms)/, "-$1");
};

cssName = memoize(cssName);

// Convert JavaScript values to strings suitable for CSS.  Converts numbers
// to dimensionts in "px" units.  Within strings, replace "#{NAME}" with
// cssName("NAME").
//
const cssValue = (value) => {
    if (typeof value == "string") {
        return value.replace(/#\{(.*?)\}/g, (_, name) => cssName(name));
    } else if (typeof value == "number") {
        return value + "px";
    } else {
        return "";
    }
};

//------------------------------------------------------------------------
// Construct non-conflicting class names
//------------------------------------------------------------------------

const allNames = new Set();
let nextNum = 1;

// Return a name different from all previous results
//
const getUniqueName = (name) => {
    while (allNames.has(name)) {
        // append or replace trailing number with a new one
        const m = name.match(/(.*?)(\d*)$/);
        name = m[1] + nextNum++;
    }
    allNames.add(name);
    return name;
};

const releaseUniqueName = (name) => {
    allNames.delete(name);
};

//------------------------------------------------------------------------
// Dynamic style sheet manipulation
//------------------------------------------------------------------------

// Add a new stylesheet to hold our generated CSS rules
D.head.appendChild(newElement("style"));
const styleSheet = D.styleSheets[D.styleSheets.length - 1];

// Dynamically create an empty style sheet rule, and return the style
// object.
//
const insertRule = (selector) => {
    styleSheet.insertRule(selector + " {}", 0);
    return styleSheet.cssRules[0];
};

// Remove rules matching selectors.
//
const deleteRules = (selectorSet) => {
    let rule;
    for (let i = 0; (rule = styleSheet.cssRules[i]) != null; ++i) {
        if (selectorSet.has(rule.selectorText)) {
            styleSheet.deleteRule(i);
            --i;
        }
    }
};

// Assign an individual property to a style object.
//
const setStyleProperty = (style, name, value) => {
    name = cssName(name);
    style[name] = (value == null ? "" : cssValue(value));
};

// Apply declarations in `decls` to style object `style`
//
const setStyleProperties = (style, decls) => {
    if (decls) {
        for (let key in decls) {
            setStyleProperty(style, key, decls[key])
        }
    }
};

// Replace "&" wildcard in pattern with `context`
//
const expandSelector = (pattern, context) =>
      pattern ? pattern.replace(/\&/g, context) : context;

// Create and add a stylesheet rule for each member of rules[].
//
let defineRules = (rules, context) => {
    //const selectorSet = new Set();  [for cleanup]
    for (const {selector, decls} of rules || []) {
        const style = insertRule(expandSelector(selector, context)).style;
        setStyleProperties(style, decls);
    }
};

//------------------------------------------------------------------------
// DOM Node manipulation & ElemFactory
//------------------------------------------------------------------------

let setListener = (elem, name, fn) => {
    elem.addEventListener(name, fn);
};

let setListeners = (e, o) => {
    for (let name in o) {
        setListener(e, name, o[name]);
    }
};

// Set attribute `name` to `value`.  Do not assume values have not already
// been set on the element; this can be re-evaluted in an isolated function.
//
let setAttr = (e, name, value) => {
    if (typeof value == "function") {
        throw Error("bad attribute");
    } else {
        // HTML attributes are case-insensitive, but SVG is case-sensitive,
        // so we cannot convert camelCase to dashed-words.  Ironically, SVG
        // also uses dash-delimited attribute names, and is the main case in
        // which we would have liked to use camelCase as shorthand.
        e.setAttribute(name, String(value));
    }
};

let setAttrs = (e, attrs, autoClass) => {
    for (let key in attrs) {
        setAttr(e, key, attrs[key]);
    }
    if (autoClass != "") {
        // If attrs.class was set above, we will override it here.
        // Note: Setting `e.className` does not work for SVG elements.
        setAttr(e, "class", autoClass + (attrs.class ? " " + attrs.class : ""));
    }
};

let badNodes = [];

let badNodeText = (value) => {
    // window.BADNODES = badNodes;   // expose for debugging
    badNodes.push(value);
    return D.createTextNode("<BADNODE[" + (badNodes.length - 1) + "]>");
};

let prepareNode = (node) =>
    (node instanceof Node
     ? node
     : D.createTextNode(typeof node == "string" ? node :
                        node == null ? "" :
                        badNodeText(node)));

// Replace content of element `e` with `content` (a string, DOM element, or
// array of strings/elements).
//
let setContent = (e, content) => {
    // Remove existing content
    while (e.firstChild) {
        e.removeChild(e.firstChild);
    }

    let appendContent = child => {
        // Allow "holes" in the content array
        if (child instanceof Array) {
            child.forEach(appendContent);
        } else if (child != null && child !== "") {
            e.appendChild(prepareNode(child));
        }
    };

    appendContent(content);
};

//----------------------------------------------------------------
// E: Element Factory
//----------------------------------------------------------------

// ElemState objects are internal values that store information required for
// creation of DOM elements or derived factories.
//
//   tag      = DOM element tag name
//   ns       = null, or XML namespace
//   attrs    = object: attributeName -> string
//             *or* `$<elementPropertyName>` -> value
//   events   = object: event name -> function
//   name     = base for class name generation
//   selector = a selector used to identify elements created from the EF
//             instance, such as ".C0.C1".  The selector includes class
//             names of each parent EF in order to increase the specificity
//             of the resulting rule.
//

// Extract components of a `props` value.
//
//   esIn: ElemState
//   props: ElemProps
//
let splitProps = (esIn, propsIn) => {
    let es = {...esIn};
    let rules = [];

    let split = (props, selector) => {
        let decls;

        for (let key in props) {
            let value = props[key];
            if (key[0] == "$") {
                // non-CSS property
                if (selector) {
                    throw new Error("Non-CSS option inside pattern rule: "
                                    + selector + " {" + key + ": ...}")
                } else if (key == "$tag") {
                    es.tag = value;
                } else if (key == "$ns") {
                    es.ns = value;
                } else if (key == "$events") {
                    es.events = value;
                } else if (key == "$name") {
                    es.name = value;
                } else if (key == "$attrs") {
                    es.attrs = {...es.attrs, ...value};
                } else {
                    throw new Error("Bad prop: " + key);
                }
            } else if (/\&/.test(key)) {
                // selector pattern
                split(value, expandSelector(key, selector || "&"));
            } else {
                decls = decls || {};
                decls[key] = value;
            }
        }
        rules.push({selector, decls});
    };
    split(propsIn);

    return [es, rules];
};

// Create a derived ElemState value
//
let createES = (esIn, props) => {
    let [es, rules] = splitProps(esIn, props);

    if (rules.length > 1 || rules[0].decls) {
        es.selector = es.selector + "." + getUniqueName(es.name);
        defineRules(rules, es.selector);
    }
    return es;
};

// Create a DOM element
//
let createElem = (esIn, props, content) => {
    let [es, rules] = splitProps(esIn, props);
    let {tag, ns, attrs, events, selector} = es;

    let e = newElement(tag, ns);

    if (rules[1]) {
        // Selector patterns require a stylesheet rule.  In this case, we
        // avoid using the element's style object, so that a "#I0:hover"
        // sub-rule will override "#I0" as intended.
        attrs.id = attrs.id || getUniqueName("I0");
        defineRules(rules, "#" + attrs.id);
    } else {
        // In the simple case we do not need a stylesheet rule.
        setStyleProperties(e.style, rules[0].decls);
    }

    setAttrs(e, attrs, selector.replace(/\./g, " ").substr(1));
    setContent(e, content);
    setListeners(e, events || []);
    return e;
};

// Construct a new factory function/object.
//
let newFactory = (es) => {
    let f = (props, ...content) =>
        (props instanceof Array
         ? createElem(es, null, [props, ...content])
         : createElem(es, props, content));

    f.set = (props) => newFactory(createES(es, props));

    return f;
};

let E = newFactory({
    tag: "div",
    ns: null,
    attrs: {},
    selector: "",
    name: "E0",
});

export {
    E as default,
    E,
    setContent,
};

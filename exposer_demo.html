<!DOCTYPE html>
<html lang=en>
  <head>
    <meta charset=utf-8>
    <style>
      body {
          background-color: #eee;
          font: 16px Arial;
          height: 1000px;
          width: 1000px;
          user-select: none;
          -webkit-user-select: none;
          background-image:
              linear-gradient(to right, rgb(0 0 0 / 15%) 2%, rgb(0 0 0 / 0%) 4% 96%, rgb(0 0 0 / 15%) 98%),
              linear-gradient(rgb(0 0 0 / 15%) 2%, rgb(0 0 0 / 0%) 4% 96%, rgb(0 0 0 / 15%) 98%);
          background-size: 150px 150px;
      }

      .box {
          font-size: 8px;
          touch-action: none;
          touch-action: manipulate;
          position: absolute;
          box-sizing: border;
          width: 50px;
          height: 50px;
          border: 5px solid black;
          border-radius: 5px;
          user-select: none;
          text-align: center;
          padding: 3px;
          -webkit-user-select: none;
          background-color: #ddd;
      }

      .box#big  {
          width: 200px;
          height: 300px;
      }

      .box.state1 { background-color: #ee8; }    /* being dragged */
      .box.moved { border-color: blue; }         /* has moved since "start" */
      .box.error { background-color: #f00; }     /* invalid state */

      /* This rectangle limits the region to be exposed */
      #limit {
          position: absolute;
          box-sizing: border-box;
          top: 4em;
          left: 20px;
          width: 950px;
          height: 950px;
          border: 2px solid #8cc;
      }

      .statsTable {
          /* font: 12px Arial; */
          border-collapse: collapse;
          position: absolute;
          top: 60px;
          left: -25px;
      }

      .statsTable th, .statsTable td {
          border: 2px solid #ccc;
      }
      .statsTable .nw {
          white-space: nowbrap;
          overflow: hidden;
          width: 4em;
      }

    </style>
  </head>
  <body>

    <p>
      <input type=button id=statsOnOff value="Stats"></button>
    </p>
    <div id=limit></div>
    <div class=box style="left: 100px; top: 150px;"><div>Drag me</div></div>
    <div class="box" id=big style="left: 200px; top: 150px;"><div>Drag me</div></div>


<script type=module>

  import {handleDrag, listen} from "./drag.js";
  import Exposer from "./exposer.js";

  let SE = document.scrollingElement;
  let VV = window.visualViewport;

  let pageFromClient = (r) => {
      return {
          left: r.left + window.scrollX,
          top: r.top + window.scrollY,
          width: r.width,
          height: r.height,
      };
  };

  //----------------------------------------------------------------
  // Buttons & Stats
  //----------------------------------------------------------------

  let byid = (id) => document.getElementById(id);

  let ce = (tag, ...chilluns) => {
      let e = document.createElement(tag);
      for (let child of chilluns) {
          if (typeof child == "string") {
              child = document.createTextNode(child);
          }
          e.appendChild(child);
      }
      return e;
  };

  let boxes = [...document.getElementsByClassName("box")];

  let statsShown = false;
  let showStats = () => {
      if (statsShown) {
          return;
      }
      statsShown = true;

      let statsTable = ce("table");
      statsTable.className = "statsTable";

      let addStatsLine = (desc, keys, obj) => {
          keys.forEach( (key) => {
              let hdr = desc + "." + key;
              let valueElem = ce("div");
              valueElem.className = "nw";
              statsTable.appendChild(ce("tr", ce("th", hdr), ce("td", valueElem)));
              let fn = (typeof obj == "function" ? obj : (k => obj[k]));

              let update = () => {
                  valueElem.innerText = fn(key);
                  requestAnimationFrame(update);
              };
              update();
          });
      };

      // Display different ways of computing viewport

      addStatsLine("window", ["scrollX", "scrollY"], window);
      addStatsLine("SE", ["clientWidth", "clientHeight"], SE);
      if (VV) {
          addStatsLine("VV", ["pageLeft", "pageTop", "width", "height"], VV);
      } else {
          statsTable.appendChild(ce("tr", ce("th", "VV"), ce("td", "n/a")));
      }

      boxes[1].appendChild( statsTable );
  };

  byid("statsOnOff").onclick = showStats;


  let limit = byid("limit");
  let limitRect = pageFromClient(limit.getBoundingClientRect());

  //----------------------------------------------------------------
  // Draggable boxes
  //----------------------------------------------------------------

  let round = x => Math.floor(x*10) / 10;
  let fmtTopLeft = r => "(" + round(r.left)  +"," + round(r.top) + ")";
  let toNum = (str) => Number(str.match(/[0-9\.]*/)[0]);
  let pxAdd = (px, n) => (toNum(px) + n) + 'px';

  let makeDraggable = (e) => {
      let style = e.style;
      let state = 0;

      let label = e.firstElementChild;

      // For every "start" there should be exactly one "stop".
      //
      let checkAndSetState = (expected, newState) => {
          let old = state;
          state = newState;
          if (old != expected) {
              e.className = "box error";
              console.log("state = " + state + ", expected " + expected);
          } else {
              e.className = "box state" + state;
          }
      };

      let dragX = 0;
      let dragY = 0;
      let setDrag = (dx, dy) => {
          dragX = dx;
          dragY = dy;
          style.transform = "translate(" + dx + "px, " + dy + "px)"
      };

      let exposer;

      let dragTarget = {
          dragStart: () => {
              checkAndSetState(0, 1);
              dragX = dragY = 0;
              exposer = Exposer(
                  e, limitRect, 10,
                  (dx, dy) => setDrag(dragX + dx, dragY + dy));
              exposer(true);
          },

          dragStop: (isDrop) => {
              style.transform = "";
              exposer(false);
              checkAndSetState(1, 0);
              if (isDrop) {
                  style.left = pxAdd(style.left, dragX);
                  style.top = pxAdd(style.top, dragY);
              }
          },

          dragMove: (dx, dy, event) => {
              e.classList.add("moved");
              setDrag(dx, dy);
              let client = e.getBoundingClientRect();
              let page = pageFromClient(client);

              label.innerHTML = "Client:<br>" + fmtTopLeft(client) + "<br>Page:<br>" + fmtTopLeft(page);

              exposer(true);
          },
      };

      handleDrag(e, dragTarget);
  };

  boxes.forEach(makeDraggable);

</script>

  </body>
</html>

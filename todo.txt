Current
=======

 - grid: create per-column factory for data cells
 - drag: leverage `listen` from e.js?
 - demo: Demo needn't/shoudn't be `posn: abs`
 - demo: provide buttons for un-render / re-render
 - I: When outside of any cell, memos are no-ops
 - I: Make "isolate" lightweight when a no-op (no child cells)
 - I: refactor...
    * Describe `memo`
    * defer(f, ...args)
         defer(_ => f(a,b))  <-->   defer(f, a, b)
    * Remove deferMemo
         deferMemo(f)(a,b)    -->   defer(memo(f), a,b)
 - I: Document "monitoring": "during execution of a cell, its accesses of
   other cells (inputs, intermediates) are logged."

 - E: Optimize setContent? (not re-populate all children?)
 - E: dereg listener on drop? [needed?]
 - E: $ns -> $attr:{ xmlns=... }
 - Validate "clean" install using "npm update"


For readme...
=====

 * `$ npm update` installs dependencies.

 * FOO_q.js => test for FOO.js
   FOO_demo.js => interactive demo/test for FOO.js; view with `make index`

 * Javascript sources are ES "modules", and should be directly usable,
   as-is, by a browser or Node.js.  This implies:

   - Imports must use relative paths beginning with "./" or "../".
     (Browsers require this -- or "/", which would mean different things in
     different contexts.)

   - We add `"type":"module"` to package.json so Node will recognize them
     as such.

 * `./test.js` is remapped to `./no-test.js` when bulding bundles for the
   browser.  With minification, this also discards embedded unit tests.


Longer-term
=====

 * Ultimately we want a reactive FS veneer.  It should make it easy to avoid
   race conditions & locking, or provide an alternative (temporary
   duplication).  For example, changing a song title may require
   modifying/inserting 20 bytes near the end of a 3MB file, but if the file
   has been modified since our read, we could corrupt it.  In the imperative
   model one has to deal with the same problems, but languages and libraries
   in that model are ill-equipped to provide a generic solution to race
   condition problem.

 * PVS: View state that should persist beyond the lifetime of the view --
   not part of the model (the data being viewed) and not part of the view
   class (all instances).  [E.g.: column widths.]  Perhaps this could be
   "automatically" arrived at by the view, based on its "location" -- that
   is, where in the DOM tree it is rendered, and in which application.
   Better yet, its location within an app would be determined more nicely by
   non-DOM parent nodes that exist for addressing purposes.  The current
   e.js model (creation of DOM nodes when views are created) means we cannot
   know *where* we are in the tree until some unknown later point in time.

 * wrap() optimized for constant case, so 'isolate(...demand(...))' is
   efficient. [TODO: memo & onDrop; keep in mind fn vs. cell vs. invocation]

      const g_cc = [];  // cell children

      const isolate = (fn) => {
         const ccn = g_cc.length;
         const result = fn();
         if (ccn != g_cc.length) {
            g_cc[ccn] = new Cell(g_cc.slice(ccn, g_cc.length), result);
            g_cc.length = ccn+1;
         }
         return result;   // nothing to do
      }

      class Cell {
         // we do not know our parent at creation time...
         constructor (children, result) {
            this.children = children;
            this.result = result;
            this.parent = nullParent;
            children.forEach(c => c.parent = cell);
         }
      }
